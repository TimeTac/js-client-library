/**
 * This file was auto-generated by swagger-to-ts.
 * Do not make direct changes to the file.
 */

export interface components {
  schemas: {
    authentication_getaccesstoken: {
      grant_type?: 'refresh_token' | 'password';
      client_id?: string;
      client_secret?: string;
      username?: string;
      password?: string;
      refresh_token?: string;
    };
    absenceBans: {
      id?: number;
      department_id?: number;
      reason?: string;
      date_from?: string;
      date_to?: string;
      /**
       * Timestamp of last change
       */
      _since?: string;
    };
    absenceDays: {
      id?: number;
      user_id?: number;
      user_department_id?: number;
      user_role_id?: number;
      date?: string;
      type?: string;
      other_paid_leave_id?: number;
      value?: number;
      value_unit?: string;
      request_id?: number;
      status?: number;
      comment?: string;
      begin?: string;
      updated?: string;
    };
    absenceMultistageResponsibilities: {
      id?: number;
      options_id?: number;
      request_id?: number;
      user_id?: number;
      /**
       * level of the chane
       */
      level?: number;
      /**
       * 0 - open; 1 - ready for approval; 2- approved; 3 - declined
       */
      status?: number;
      /**
       * Comment of the request response in this level/interation
       */
      comment?: string;
      data_changed?: string;
    };
    absences: {
      id?: number;
      type_id?: number;
      subtype_id?: number;
      user_id?: number;
      /**
       * The user replacement for this request.
       */
      replacement_user_id?: number;
      /**
       * The department id to which the request user (request_user_id) was assigned at the time of holiday request
       */
      request_user_department_id?: number;
      /**
       * The department role id to which the request user (request_user_id) was assigned at the time of holiday request
       */
      request_user_role_id?: number;
      created?: string;
      status?: number;
      granted_user_id?: number;
      granted_as_substitute_user_id?: number;
      granted_timestamp?: string;
      request_comment?: string;
      granted_comment?: string;
      from_date?: string;
      to_date?: string;
      duration?: number;
      /**
       * If the request ends with a partial day, the value of the last partial day.
       */
      request_partial_begin_duration?: number;
      /**
       * If the request begins with a partial day, the value of the first partial day.
       */
      request_partial_end_duration?: number;
      duration_unit?: string;
      begin?: string;
      substitute_enabled?: boolean;
      /**
       * Arbitrary data for requests
       */
      individual_value_1?: string;
      /**
       * If the multistage approval for this reuest is active.
       */
      is_multistage_request?: boolean;
      /**
       * The last level in the chain responsibility table (autoupdated) that is not approved yet
       */
      chain_level?: number;
      updated?: string;
    };
    absenceTypes: {
      /**
       * Id of the absence.
       */
      id?: number;
      /**
       * Id of the absence type.
       */
      absence_type_id?: number;
      /**
       * Id of the sub absence (other paid leaves).
       */
      absence_subtype_id?: number;
      /**
       * Group of the absence defined in pm_absece_groups.
       */
      absence_group_id?: number;
      /**
       * Sort order in views.
       */
      sort_order?: number;
      /**
       * Absence name.
       */
      name_const?: string;
      /**
       * Absence abbrevation constant.
       */
      abbreviation_const?: string;
      /**
       * If the absence is shown in the selection for user.
       */
      show_in_selection?: boolean;
      /**
       * The task_id of pm_tasks_subprojects which will be used to automatically create timestamps based on the absence.
       */
      cost_acc_task_id?: number;
      /**
       * If the users can request this absence.
       */
      enabled_for_requests?: boolean;
      /**
       * If the leave should be added to working hours.
       */
      add_to_working_hours?: boolean;
      /**
       * If 0, the the user cannot enter more time of the day of absence as the target working hour according to his working time model.
       */
      allow_tracking_more_then_target_working_hours?: boolean;
      /**
       * The possible types are WORKFLOW, USER, HR_MANAGER, MANAGER, SYSTEM
       */
      request_type?: string;
      /**
       * Whether the absence can be entered on a non working day like weekends and public holidays
       */
      allow_entry_on_non_working_days?: boolean;
      /**
       * Whether the type of absence ALWAYS will be shown in the team calendar independently of the user setting: "Show type of absence..."
       */
      public_leave_type?: boolean;
      /**
       * Whether the comment field in the application window needs to be filled out by the applicant.
       */
      comment_is_mandatory?: boolean;
      /**
       * Whether the comment field in the rejection window is mandatory or not.
       */
      reject_request_comment_is_mandatory?: boolean;
      /**
       * This JSON setting tells which days should be shown in the request window for the duration. Defaults are 0.25, 0.50, 0.75 and 1. Amounts can be added, removed or changed. The value needs to be a valid JSON string. The durations are procentual digits separated by a comma. (so for 0.10 add 10).
       */
      show_day_amount_config?: string;
      /**
       * Duration unit of the absence (hours or days).
       */
      duration_unit?: string;
      /**
       * Whether the user limitation config is enabled for this absence.
       */
      enable_user_limitations?: boolean;
      /**
       * If enable_user_limitations is enabled, the JSON config for the limitation
       */
      user_limitations_config?: string;
      /**
       * Whether to enable/disable the substitute mode for the leave type. e.g. usually during the absence home office we dont need the substitute to handle all requests.
       */
      enable_for_substitute_mode?: boolean;
      /**
       * If request_type = "USER" and the user enters an absence, a notification email will be sent to the responsible manager.
       */
      send_email_notification_to_responsible_manager?: boolean;
      /**
       * If a manager enters an absence for somebody else, this person will be notified by email of this entry.
       */
      send_email_notification_to_user_if_entered_by_manager?: boolean;
      /**
       * The HEX code for the color to be shown in the holiday planers.
       */
      color?: string;
      /**
       * If there is a country restriction for this other paid leave. The limitations are defined in pm_working_hour_other_paid_leave_to_countries.
       */
      restrict_for_country?: boolean;
      /**
       * If a replacement is needed for this absence.
       */
      absence_window_show_replacement?: boolean;
      /**
       * Datev key
       */
      datev_absence_key?: string;
      /**
       * Datev wage type id
       */
      datev_wage_type_id?: number;
      individual_value_1?: string;
      /**
       * Tells if user can edit it in app.
       */
      is_visible_for_edit?: boolean;
    };
    absenceTypesRestrictToCountries: {
      id?: number;
      other_paid_leave_id?: number;
      country_id?: number;
      /**
       * 0: inactive (hidden) for country / 1: active for country
       */
      status?: boolean;
    };
    accessCredentials: {
      /**
       * Autoincrement ID for Access Credentials.
       */
      id?: number;
      /**
       * Access Credential textual identification.
       */
      name_const?: string;
      /**
       * Access Credentials textual description.
       */
      description_const?: string;
      /**
       * FK which indicates the Access Credentials Type. This field is important because it indicates on how to handle specific Access Credential row.
       */
      type_id?: number;
      /**
       * Field for storing a host data.
       */
      host?: string;
      /**
       * Field for storing a port data.
       */
      port?: number;
      /**
       * Field for storing a symmetrically encrypted username.
       */
      username?: string;
      /**
       * Field for storing a symmetrically encrypted password.
       */
      password?: string;
      /**
       * Field for storing a database name.
       */
      database_name?: string;
      /**
       * Field for storing mail sender name.
       */
      mail_sender_name?: string;
      /**
       * Field for storing mail sender address
       */
      mail_sender_address?: string;
      /**
       * Field for storing a symmetrically encrypted SMTP secure data.
       */
      mail_smtp_secure?: string;
      /**
       * Field for storing a symmetrically encrypted SMTP auth data.
       */
      mail_smtp_auth?: string;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    changeTimeTrackingRequests: {
      id?: number;
      type?: string;
      time_tracking_id?: number;
      request_user_id?: number;
      granted_user_id?: number;
      granted_as_substitute_user_id?: number;
      new_start_time?: string;
      new_end_time?: string;
      old_start_time?: string;
      old_end_time?: string;
      request_timestamp?: string;
      status?: string;
      /**
       * Comment from the user who created the request
       */
      request_user_comment?: string;
      /**
       * Comment from the user who handled the request.
       */
      granted_user_comment?: string;
      data_changed?: string;
    };
    checkpoints: {
      id?: number;
      name?: string;
      mon?: boolean;
      tue?: boolean;
      wed?: boolean;
      thu?: boolean;
      fri?: boolean;
      sat?: boolean;
      sun?: boolean;
      start_time?: string;
      end_time?: string;
      mandatory?: boolean;
      task_id?: number;
      allowed_days_in_future?: number;
      allowed_days_in_past?: number;
      data_changed?: string;
    };
    checkpointTrackings: {
      id?: number;
      checkpoint_id?: number;
      time_tracking_id?: number;
      timestamp?: string;
      geo_long?: number;
      geo_lat?: number;
      geo_accuracy?: number;
      notes?: string;
      timezone?: string;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
      /**
       * Flag if the request was sent live (within 5 minutes) or postdated
       */
      is_live?: boolean;
      /**
       * oauth client id from token
       */
      oauth_client_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
    };
    clients: {
      id?: number;
      company_name?: string;
      active?: boolean;
      username?: string;
      address_1?: string;
      address_2?: string;
      zip?: string;
      city?: string;
      country_id?: string;
      url?: string;
      customer_number?: string;
      contact_person_salutation_id?: number;
      contact_person_firstname?: string;
      contact_person_lastname?: string;
      contact_person_department?: string;
      phone_1?: string;
      phone_2?: string;
      email_address?: string;
    };
    countries: { id?: number; name?: string };
    departments: {
      id?: number;
      department_name?: string;
      active?: boolean;
      supervisor_id?: number;
      supervisor_assistant_id?: number;
      mother_id?: number;
      view_order?: number;
      node_path?: string;
    };
    files: {
      id?: number;
      title?: string;
      filename?: string;
      extension?: string;
      content_type?: string;
      /**
       * Whether this file should also be stored on the filesystem
       */
      mirror_file_to_filesystem?: boolean;
      relative_url?: string;
      /**
       * Absolute URL to a stored file.
       */
      absolute_url?: string;
      path?: string;
      size?: number;
      owner?: number;
      permissions?: number;
      description?: string;
      expires?: string;
      updated?: string;
      created?: string;
    };
    generalSettingsChangeLog: {
      id?: number;
      setting_type?: string;
      old_setting_value?: string;
      new_setting_value?: string;
      /**
       * User that did the change
       */
      changed_by_user_id?: number;
      /**
       * Timestamp of change
       */
      change_timestamp?: string;
    };
    generalSettings: {
      id?: number;
      /**
       * Column to group the settings by translation constants
       */
      group_const?: string;
      setting_type?: string;
      setting_value?: string;
      is_updatable_by_customer?: boolean;
      /**
       * Sort order for settings displayed in property grid (Settings->AccountAdministration->General settings grid). Sorting starts with 1, 0 means no sort order
       */
      sort_order?: number;
      /**
       * Datatype for the editor used in property grid (Settings->AccountAdministration->General settings grid). Values: combo, number, boolean, string. If the value is combo, its values are fetched from pm_general_settings_combo_select_values
       */
      datatype?: string;
      super_user?: boolean;
      description?: string;
      default_value?: string;
      value_range?: string;
      text?: string;
      type?: number;
      update_value?: string;
      update_query?: string;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
    };
    geofences: {
      id?: number;
      /**
       * Name for display in UI
       */
      name?: string;
      /**
       * Latitude of the geofences center point
       */
      geo_lat?: number;
      /**
       * Longitude of the geofences center point
       */
      geo_long?: number;
      /**
       * Radius [meters] of the geofence
       */
      radius?: number;
      updated?: string;
    };
    geofenceToNodes: {
      id?: number;
      geofence_id?: number;
      node_id?: number;
      updated?: string;
    };
    invoices: {
      id?: number;
      invoice_number?: string;
      comment?: string;
      invoice_date?: string;
      payment_date?: string;
      net_revenue?: number;
      cost?: number;
      customer_id?: number;
      status?: boolean;
      creation_timestamp?: string;
    };
    JobParams: {
      id?: number;
      /**
       * Reference to the job (job_queue.id) to which this job belongs
       */
      job_id?: number;
      name?: string;
      value_int?: number;
      value_text?: string;
      value_double?: number;
      value_timestamp?: string;
      value_blob?: string;
    };
    JobQueues: {
      id?: number;
      /**
       * name of the task. An entry for this name must exist in the "job_config" table (either for this customer or globally in pm_general.job_config).
       */
      task?: string;
      /**
       * internal state of the scheduler (0 = waiting, 1 = scheduled, 2 = success, 3 = failed permantently). The default value of 0 (waiting) must be used for new jobs
       */
      state?: number;
      /**
       * worker name that picked up this job
       */
      claimed_by?: string;
      /**
       * Number of previous scheduling attempts.
       */
      tries?: number;
      /**
       * Date on which the job was created. The default value uses the current time. This should also not be overwritten because it is important for the scheduling sequence after a restart.
       */
      created_at?: string;
      /**
       * Job will be executed at given time.
       */
      run_at?: string;
      /**
       * Date on which the job was last shipped. Important for the time-tracking of the user accounts and the recognition of crashed jobs.
       */
      scheduled_at?: string;
      /**
       * Date on which the job was last terminated by a worker (not necessarily successful). Good for time tracking and backoff at the Rescheduling.
       */
      completed_at?: string;
      params?: { [key: string]: any };
    };
    legalDocumentAcceptanceLog: {
      /**
       * Autoincrement PK assigned to each legal document acceptance log.
       */
      id?: number;
      /**
       * FK which indicates legal document.
       */
      legal_document_type_id?: number;
      /**
       * Flag which indicates accepted state of log.
       */
      accepted?: boolean;
      /**
       * Indicates datetime when the document is accepted.
       */
      accepted_at?: string;
      /**
       * OAuth of the client who accepted legal document.
       */
      accepted_oauth_client_id?: string;
      /**
       * Indicates who accepted the legal document.
       */
      accepted_by_user_id?: number;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    legalDocuments: {
      /**
       * Autoincrement PK assigned to each legal document.
       */
      id?: number;
      /**
       * FK which indicates legal document type.
       */
      legal_document_type_id?: number;
      /**
       * Indicates the language of the legal document.
       */
      language_id?: number;
      /**
       * Version name of the legal document.
       */
      name_const?: string;
      /**
       * ID which indicates file related to this legal document.
       */
      file_id?: number;
      /**
       * Flag which defines if this document is the latest version.
       */
      latest_version?: boolean;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    legalDocumentTypes: {
      /**
       * Autoincrement PK assigned to each legal document type.
       */
      id?: number;
      /**
       * Legal document type textual identification.
       */
      name_const?: string;
      /**
       * Defines if this document has to be accepted by users.
       */
      acceptance_required?: boolean;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    messages: {
      id?: number;
      sender_id?: number;
      message?: string;
      receiver_type?: string;
      receiver_id?: number;
      include_sub_department?: boolean;
      data_changed?: string;
      timestamp_update?: string;
      timestamp?: string;
    };
    multiuserToTasks: { task_id?: number; multiuser_id?: number };
    multiuserToUsers: { assigned_user_id?: number; user_id?: number };
    nfcTransponder: {
      id?: number;
      mode_id?: number;
      unique_id?: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      created?: string;
      data_changed?: string;
    };
    nfcTransponders: {
      id?: number;
      mode_id?: number;
      unique_id?: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      created?: string;
      data_changed?: string;
    };
    nodesToUsers: {
      node?: number;
      user?: number;
      is_favourite?: boolean;
      is_todo?: boolean;
      access?: boolean;
      /**
       * Specifies a date from which on the user should be granted access
       */
      access_start?: string;
      /**
       * Specifies a date from which on the access should be revoked
       */
      access_end?: string;
      /**
       * Specifies the start date for a bookable timeframe
       */
      allow_tracking_from?: string;
      /**
       * Specifies the end date for a bookable timeframe
       */
      allow_tracking_to?: string;
      last_started?: string;
      target_duration?: number;
      revenue_per_hour?: number;
    };
    notifications: {
      id?: number;
      user_id?: number;
      notification_type?: number;
      is_response?: boolean;
      notification_timestamp?: string;
      status?: number;
      assoc_id?: number;
      user_id_sender?: number;
      user_id_responder?: number;
      processed?: boolean;
      email_send_status?: number;
      email_send_timestamp?: string;
      executable_1_id?: number;
      executable_2_id?: number;
      data_changed?: string;
    };
    notificationsTypeHtml: {
      id?: number;
      created?: string;
      status?: boolean;
      title?: string;
      /**
       * The title for email (subject), if empty, the notification title will be used
       */
      email_subject?: string;
      /**
       * The footer for email, if empty, only the greeting will be shown.
       */
      email_footer?: string;
      content?: string;
      recipient?: number;
      sender?: number;
      content_css_class?: string;
      content_css_styles?: string;
      /**
       * If this notification will be sent over email with notification manager.
       */
      send_mail_per_email_notification_manager?: boolean;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
    };
    notificationUrls: {
      id?: number;
      headline?: string;
      url?: string;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
    };
    offlineSyncError: { id?: number; user_id?: number; error?: string };
    offlineSyncErrors: { id?: number; user_id?: number; error?: string };
    permissionResolveAbsenceTypesAndUsers: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Absence id on which subject_user_id has some permission
       */
      resolve_absence_type_id?: number;
      /**
       * Absence subtype id on which subject_user_id has some permission
       */
      resolve_absence_subtype_id?: number;
      /**
       * User id on which subject_user_id has some permission
       */
      resolve_user_id?: number;
      /**
       * If subject_user_id have permissions for all absences then we will use wildcard. (e.g. * )
       */
      resolve_absence_type_wildcard?: string;
      /**
       * If subject_user_id have permissions for all subtypes of one absence type then we will use wildcard. (e.g. * )
       */
      resolve_absence_subtype_wildcard?: string;
      /**
       * If subject_user_id have permissions for all users then we will use wildcard. (e.g. * )
       */
      resolve_user_wildcard?: string;
      /**
       * User ids from which permission is inherited
       */
      inherited_user_ids?: string;
    };
    permissionResolveDepartments: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Department id on which subject_user_id has some permission
       */
      resolve_department_id?: number;
      /**
       * If subject_user_id have permissions for all users in department then we will use wildcard. (e.g. * )
       */
      resolve_department_wildcard?: string;
    };
    permissionResolveHolidayRequests: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Holiday request id on which subject_user_id has some permission
       */
      resolve_holiday_request_id?: number;
    };
    permissionResolveOauthClients: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * oauth_client id on which subject_user_id has some permission
       */
      resolve_oauth_client_id?: number;
      /**
       * If subject_user_id have permissions for all oauth_clients then we will use wildcard. (e.g. * )
       */
      resolve_oauth_client_wildcard?: string;
    };
    permissionResolveQuestions: {
      id?: number;
      question_name?: string;
      question_description?: string;
      /**
       * Which endpoint should be called to get answer for this question
       */
      question_endpoint?: string;
    };
    permissionResolveTeams: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Team id on which subject_user_id has some permission
       */
      resolve_team_id?: number;
      /**
       * If subject_user_id have permissions for all teams then we will use wildcard. (e.g. * )
       */
      resolve_team_wildcard?: string;
    };
    permissionResolveUsers: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * User id on which subject_user_id has some permission
       */
      resolve_user_id?: number;
      /**
       * If subject_user_id have permissions for all users then we will use wildcard. (e.g. * )
       */
      resolve_user_wildcard?: string;
      /**
       * User ids from which permission is inherited
       */
      inherited_user_ids?: string;
    };
    permissions: {
      id?: number;
      user_id?: number;
      resource_name?: string;
      permission_name?: string;
      permission_scope_id?: number;
      permission_scope_data_1?: number;
      permission_scope_data_2?: number;
      permission_scope_data_3?: number;
    };
    permissionScopes: {
      id?: number;
      name?: string;
      string_definition?: string;
    };
    projects: {
      id?: number;
      mother_id?: number;
      view_id?: string;
      sort_order?: number;
      node_path?: string;
      ultimate_mother_id?: number;
      name?: string;
      is_done?: boolean;
      view_order?: number;
      icon_name?: string;
      initial_duration?: number;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      object_type?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      duration?: number;
    };
    PublicHolidayTemplates: {
      id?: number;
      mother_id?: number;
      template_name?: string;
    };
    salutations: { id?: number; const?: string; gender?: string };
    schedulings: {
      id?: number;
      user_id?: number;
      task_id?: number;
      start_date?: string;
      end_date?: string;
      note?: string;
      /**
       * User id of the user that created the schedule.
       */
      created_user_id?: number;
      /**
       * Datetime of when the entry was created.
       */
      created?: string;
      /**
       * User id of the user that changed the schedule.
       */
      change_user_id?: number;
      /**
       * Datetime of when the entry was changed.
       */
      data_changed?: string;
    };
    serverEvents: {
      id?: number;
      /**
       * User id if server event is supposed to be triggered for specific user
       */
      user_id?: number;
      key?: string;
      /**
       * The value that the key should hold
       */
      value?: string;
    };
    skills: {
      id?: number;
      syn?: string;
      sort_order?: number;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      rillsoft_id?: string;
    };
    surveyAnswers: {
      /**
       * PK for survey answer.
       */
      id?: number;
      /**
       * FK to pm_user_user_settings.administrators_id which indicates a user who submitted an answer.
       */
      user_id?: number;
      /**
       * FK which links this answer to a specific submit. This is very important, since it is the only mechanism to group multiple answers from a single submit.
       */
      survey_submit_id?: number;
      /**
       * FK which links this answer to a specific question. Combined with survey_submit_id these fields are representing specific answer related to specific submit.
       */
      question_id?: number;
      /**
       * Department id of the user who created an answer
       */
      department_id?: number;
      /**
       * This represents integer value of an answer, which is carried over from pm_survey_question_definitions.value. If we need text representation for this answer it can be found at pm_survey_question_definitions.name_const
       */
      value?: number;
      /**
       * This represents textual value entered by user (in the cases where answer can be textual value). This field DOES NOT take values from pm_survey_question_definitions.name_const
       */
      value_text?: string;
      /**
       * This field defines a creation date of an answer.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveyQuestionDefinitions: {
      /**
       * PK for question definitions. Question definitions are important since they are representing the POTENTIAL answers.
       */
      id?: number;
      /**
       * FK which indicates the actual question to whom definitions are related. Basically, in terms of frontend, if question is LIST, then question_definitions are the LIST-ITEMS.
       */
      survey_question_id?: number;
      /**
       * Integer value for the question definition. This field is mandatory and important in terms of answers and further calculations.
       */
      value?: number;
      /**
       * This is textual value that can be assigned to a question definition value. It is descriptive and it wont affect calculations, but it might be used as a search pattern.
       */
      name_const?: string;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveyQuestions: {
      /**
       * PK for the survey question. Question is basically a placeholder for a possible answers, which we keep in the table pm_survey_question_definitions.
       */
      id?: number;
      /**
       * FK which indicates to which survey is this question related.
       */
      survey_id?: number;
      /**
       * This field is used to store the actual question (in a short form).
       */
      name_const?: string;
      /**
       * Description is used if question needs further explanation. For example, some questions holds explanations for the users on how to properly answer. Data like this should be stored in here.
       */
      description_const?: string;
      /**
       * Summary type defines a way to handle summaries for survey statistics.
       */
      summary_type_id?: number;
      /**
       * If 1 avg results of question are shown in grid_user_statistics
       */
      show_results_in_grid_user_statistics?: boolean;
      /**
       * If 1 avg results of question are shown in grid_department_statistics
       */
      show_results_in_grid_department_statistics?: boolean;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveys: {
      /**
       * Autoincrement PK for survey.
       */
      id?: number;
      /**
       * Survey textual identification.
       */
      name_const?: string;
      /**
       * Additional information about a survey.
       */
      description_const?: string;
      /**
       * Indicates if a survey is locked. If the survey is locked (locked = 1) it is not possible to change questions related to this survey. Default value is 0 which indicates that survey is still under the construction (SAVED or DRAFTED). Once a survey has been PUBLISHED this status is switching to locked = 1 and it stays like this permanently.
       */
      locked?: boolean;
      /**
       * This indicates if survey is open for a answers (i.e. survey can be published but inactive). Only when active = 1, new answers can be created. This status can change in time, so the survey can be active/inactive in different timeframes, allowing flexibility.
       */
      active?: boolean;
      /**
       * FK which indicates survey vote cycle. This field is very important because it defines if user answer UPDATES existing one or counts as a new INSERT.
       */
      vote_cycle_id?: number;
      /**
       * Indicates creator of a survey. This is not a FK because there is no creator if system survey exists.
       */
      creator_user_id?: number;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveySubmits: {
      /**
       * PK for survey submits. Survey submit represents one event (REQUEST) when user clicked button submit.
       */
      id?: number;
      /**
       * Timestamp which defines actual survey submit date/time.
       */
      created_at?: string;
    };
    tasks: {
      id?: number;
      mother_id?: number;
      view_id?: string;
      sort_order?: number;
      node_path?: string;
      ultimate_mother_id?: number;
      name?: string;
      is_done?: boolean;
      view_order?: number;
      icon_name?: string;
      initial_duration?: number;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      object_type?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      duration?: number;
    };
    teamMembers: { team_id?: number; user_id?: number };
    teams: {
      id?: number;
      name?: string;
      team_leader_id?: number;
      /**
       * Foreign key to map pm_task_subprojects relations
       */
      project_id?: number;
      data_changed?: string;
      /**
       * Concanated string of all the members
       */
      current_team_members?: string;
      /**
       * TTW-2805: do not change manually - column changes automatically to 1 if there are entries in  pm_user_with_teamplaner_access
       */
      use_pm_user_with_teamplaner_access_table?: boolean;
      /**
       * TTW-2805: do not change manually - column changes automatically to 1 if there are entries in  pm_user_with_teamplaner_access
       */
      current_user_with_teamplaner_access?: string;
    };
    timePlannings: {
      id?: number;
      user_id?: number;
      task_id?: number;
      scheduling_id?: number;
      shift_id?: number;
      /**
       * The recurring element this planning entry belongs to
       */
      recurring_elements_id?: number;
      department_node_path?: string;
      /**
       * The department id to which the timeplannings user (pm_time_planning.user_id) was assigned at the time start_date of the timePlanning.
       */
      department_id?: number;
      /**
       * The department role id to which the timeplannings user (pm_time_planning.user_id) was assigned at the time start_date of the timePlanning.
       */
      department_role_id?: number;
      task_node_path?: string;
      project_leader_id?: number;
      is_nonworking?: boolean;
      skill_id?: number;
      client_id?: number;
      year?: number;
      yearmonth?: string;
      month?: number;
      start_date?: string;
      start_time?: string;
      end_time?: string;
      duration?: number;
      status?: number;
      cost_user?: number;
      cost_task?: number;
      revenue_user?: number;
      revenue_task?: number;
      push_trigger?: string;
      is_billable?: boolean;
      notes?: string;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      u_iv_1?: string;
      u_iv_2?: string;
      u_iv_3?: string;
      u_iv_4?: string;
      u_iv_5?: string;
      u_iv_6?: string;
      cost_acc_type?: string;
      is_paid_non_working?: boolean;
      /**
       * Has a timestamp been created in the cronjob.
       */
      timestamp_created?: boolean;
      /**
       * User id of the user that created the time planning.
       */
      created_user_id?: number;
      /**
       * Datetime of when the entry was created.
       */
      created?: string;
      /**
       * User id of the user that changed the entry.
       */
      change_user_id?: number;
      data_changed?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
    };
    timesheetAccountings: {
      id?: number;
      user_id?: number;
      department_id?: number;
      /**
       * The department role id to which the user (user_id) was assigned at the time of timesheetAccounting
       */
      user_role_id?: number;
      date?: string;
      approved_by_user?: boolean;
      approved_by_admin?: boolean;
      approved_by_user_1?: boolean;
      ordinary_hours?: number;
      target_working_hours?: number;
      begin_time?: string;
      end_time?: string;
      break?: number;
      flexible_working_time?: number;
      core_working_time?: number;
      working_time?: number;
      /**
       * Planned time of day
       */
      working_time_planned?: number;
      user_defined_time_1?: number;
      user_defined_time_2?: number;
      user_defined_time_3?: number;
      user_defined_time_4?: number;
      user_defined_time_5?: number;
      user_defined_time_6?: number;
      user_defined_time_7?: number;
      user_defined_time_8?: number;
      excess_work?: number;
      excess_work_consumption?: number;
      excess_work_adjustments?: number;
      excess_work_balance?: number;
      overtime_1?: number;
      overtime_1_consumption?: number;
      overtime_1_adjustments?: number;
      overtime_1_balance?: number;
      overtime_2?: number;
      overtime_2_consumption?: number;
      overtime_2_adjustments?: number;
      overtime_2_balance?: number;
      overtime_3?: number;
      overtime_3_consumption?: number;
      overtime_3_adjustments?: number;
      overtime_3_balance?: number;
      overtime_4?: number;
      overtime_4_consumption?: number;
      overtime_4_adjustments?: number;
      overtime_4_balance?: number;
      overtime_5?: number;
      overtime_5_consumption?: number;
      overtime_5_adjustments?: number;
      overtime_5_balance?: number;
      overtime_6?: number;
      overtime_6_consumption?: number;
      overtime_6_adjustments?: number;
      overtime_6_balance?: number;
      total_working_time?: number;
      paid_nonworking_time?: number;
      paid_nonworking_time_set_by_user?: number;
      total_working_time_incl_paid_non_working_time?: number;
      working_time_daily_balance?: number;
      working_time_daily_balance_incl_standby?: number;
      additions?: number;
      overtime_allowance?: number;
      overtime_paid?: number;
      overtime_reduction?: number;
      working_time_total_balance?: number;
      public_holiday?: number;
      holiday?: number;
      holiday_adjustments?: number;
      holiday_balance?: number;
      tmp_holiday_balance?: number;
      sick_leave?: number;
      sick_leave_adjustments?: number;
      sick_leave_balance?: number;
      other_paid_leave?: number;
      other_paid_leave_id?: number;
      user_defined_day_1?: number;
      user_defined_day_1_adjustments?: number;
      user_defined_day_1_balance?: number;
      user_defined_day_2?: number;
      user_defined_day_2_adjustments?: number;
      user_defined_day_2_balance?: number;
      user_defined_day_3?: number;
      user_defined_day_3_adjustments?: number;
      user_defined_day_3_balance?: number;
      user_defined_day_4?: number;
      user_defined_day_5?: number;
      user_defined_day_6?: number;
      user_defined_day_7?: number;
      user_defined_day_8?: number;
      comment?: string;
      data_changed?: string;
      break_law_check?: number;
      workday?: boolean;
      weekday?: number;
      /**
       * Meant to allow grouping by year
       */
      year?: number;
      /**
       * Meant to allow grouping by month
       */
      month?: number;
      /**
       * Meant to allow grouping by week
       */
      week?: number;
    };
    timesheetAccountingSummaries: { user_id?: number };
    timesheetActionLogs: {
      id?: number;
      user_id?: number;
      /**
       * The department id to which the user (user_id) was assigned at the time of absenceDay
       */
      user_department_id?: number;
      /**
       * The department role id to which the user (user_id) was assigned at the time of absenceDay
       */
      user_role_id?: number;
      date?: string;
      type?: string;
      other_paid_leave_id?: number;
      value?: number;
      value_unit?: string;
      request_id?: number;
      /**
       * Reflects the status from pm_holiday_requests (absence).
       */
      status?: number;
      comment?: string;
      begin?: string;
      updated?: string;
    };
    timeTrackingChangelogs: {
      id?: number;
      change_timestamp?: string;
      change_type?: string;
      /**
       * Change reason: 0 - default, 1 - Automatic Brake, 2 - Round Timers
       */
      change_reason_id?: number;
      /**
       * logged in user_id at change time
       */
      change_user_id?: number;
      tracker_id?: number;
      user_id?: number;
      task_id?: number;
      start_time?: string;
      /**
       * The new start time of the timestamp
       */
      new_start_time?: string;
      end_time?: string;
      /**
       * The new end time of the timestamp
       */
      new_end_time?: string;
      duration?: number;
    };
    timeTrackings: {
      id?: number;
      user_id?: number;
      /**
       * The department id to which the timetrackings user (pm_time_tracking.user_id) was assigned at the time start_date of the timeTracking.
       */
      department_id?: number;
      /**
       * The department role id to which the timetrackings user (pm_time_tracking.user_id) was assigned at the time start_date of the timeTracking.
       */
      department_role_id?: number;
      task_id?: number;
      start_time?: string;
      end_time?: string;
      start_time_offset?: number;
      end_time_offset?: number;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
      timezone?: string;
      /**
       * Whether the start of the timer was booked live or not
       */
      is_start_live?: boolean;
      /**
       * Whether the end of the timer was booked live or not
       */
      is_end_live?: boolean;
      time?: string;
      duration?: number;
      status?: number;
      start_ip?: string;
      end_ip?: string;
      is_statistic_countable?: boolean;
      max_hours_alert?: boolean;
      input_type?: number;
      t_iv_1?: string;
      /**
       * if 1, admin has approved time tracking entry (no change possible)
       */
      approved_by_admin?: boolean;
      geo_start_lat?: number;
      geo_start_long?: number;
      geo_start_accuracy?: number;
      geo_end_lat?: number;
      geo_end_long?: number;
      geo_end_accuracy?: number;
      geo_lat?: number;
      geo_long?: number;
      geo_accuracy?: number;
      updated?: string;
      /**
       * Id of latest time tracking change request
       */
      last_change_time_tracking_request_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timezones: { id?: number; timezone?: string };
    translations: { translation_key?: string; value?: string };
    userDefinedFieldDefinitionOptions: {
      id?: number;
      field_id?: string;
      field_option_id?: number;
      field_option_value?: string;
      /**
       * When active is set to 0, the option disabled in the combo.
       */
      active?: boolean;
      /**
       * Sort order of user defined field if combobox.
       */
      sort_order?: number;
    };
    userDefinedFieldDefinitions: {
      id?: string;
      entity?: string;
      fieldname?: string;
      fieldtype?: string;
      aggregation_type?: string;
    };
    users: {
      id?: number;
      active?: boolean;
      department_id?: number;
      department_id_valid_from?: string;
      role_id?: number;
      start_task_at_login?: number;
      username?: string;
      personnel_number?: string;
      lastname?: string;
      firstname?: string;
      fullname?: string;
      abbrevation?: string;
      restrict_to_ip?: boolean;
      permission_show_tt_ex_post_one_employees?: boolean;
      permission_show_assign_favourites?: boolean;
      permission_show_assign_todos?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      password?: string;
      email_address?: string;
      language_id?: number;
      phone?: string;
      skype?: string;
      profile_picture?: string;
      u_iv_1?: string;
      u_iv_1_valid_from?: string;
      u_iv_2?: string;
      u_iv_2_valid_from?: string;
      u_iv_3?: string;
      u_iv_3_valid_from?: string;
      u_iv_4?: string;
      u_iv_4_valid_from?: string;
      u_iv_5?: string;
      u_iv_5_valid_from?: string;
      u_iv_6?: string;
      u_iv_6_valid_from?: string;
      mobile_allowed?: boolean;
      pin_code?: string;
      country_id?: number;
      allowed_ips?: string;
      payroll_accounting_starts_at?: string;
      payroll_accounting_initial_value_working_time_total_balance?: number;
      public_holiday_template_id?: number;
      public_holiday_template_id_valid_from?: string;
      manual_timetracking?: boolean;
      automatic_tracker_writing_task_id?: number;
      cost_acc_non_working_task_id?: number;
      phone_1?: string;
      phone_2?: string;
      birthday?: string;
      entry_date?: string;
      exit_date?: string;
      notes?: string;
      social_security_number?: string;
      address_1?: string;
      address_2?: string;
      zip?: string;
      permission_show_edit_user_user_settings?: boolean;
      terminal_transponder_nr?: string;
      external_id?: string;
      company_name?: string;
      timesheet_template_id?: number;
      timesheet_template_id_valid_starting_from?: string;
      timesheet_holiday_calc_yearly_amount?: number;
      timesheet_holiday_calc_starting_from?: string;
      timesheet_holiday_calc_interval_mode?: string;
      working_time_balance_rule?: number;
      working_time_balance_rule_valid_from?: string;
      overtime_allowance_included_overtime_hours_per_cycle?: number;
      payroll_accounting_initial_value_holiday?: number;
      timetac_product_id?: number;
      enable_module_employee_timetracking?: boolean;
      enable_module_project_timetracking?: boolean;
      enable_module_leave_management?: boolean;
      enable_module_shift_planning?: boolean;
      leave_note?: string;
      request_substitute_user_id?: number;
      time_tracking_ex_post_earliest_working_time?: string;
    };
    userStatusOverview: {
      user_id?: number;
      /**
       * Time tracking id of a running task
       */
      time_tracking_id?: number;
      time_tracking_start_time?: string;
      time_tracking_start_time_timezone_id?: string;
      time_tracking_task_id?: number;
      time_tracking_is_nonworking?: boolean;
      /**
       * 1 if there is core time violation, default 0
       */
      core_time_violation?: boolean;
      core_time_start?: string;
      updated?: string;
      is_running?: boolean;
      /**
       * Current absence ids
       */
      current_absence_ids?: string;
      /**
       * Represents current status of users activity if he is offline (0), working(1),break(2),on leave(3), core time violation (5)
       */
      status?: number;
    };
    absenceBans_create: {
      department_id: number;
      reason: string;
      date_from: string;
      date_to: string;
    };
    absenceBans_read: {
      id?: number;
      department_id?: number;
      reason?: string;
      date_from?: string;
      date_to?: string;
      /**
       * Timestamp of last change
       */
      _since?: string;
    };
    absenceBans_update: {
      id: number;
      department_id?: number;
      reason?: string;
      date_from?: string;
      date_to?: string;
    };
    absenceDays_read: {
      id?: number;
      user_id?: number;
      user_department_id?: number;
      user_role_id?: number;
      date?: string;
      type?: string;
      subtype_id?: number;
      value?: number;
      value_unit?: string;
      request_id?: number;
      status?: number;
      comment?: string;
      begin?: string;
      updated?: string;
      type_id?: number;
    };
    absenceMultistageResponsibilities_read: {
      id?: number;
      options_id?: number;
      request_id?: number;
      user_id?: number;
      /**
       * level of the chane
       */
      level?: number;
      /**
       * 0 - open; 1 - ready for approval; 2- approved; 3 - declined
       */
      status?: number;
      /**
       * Comment of the request response in this level/interation
       */
      comment?: string;
      data_changed?: string;
    };
    absences_approve: {
      id: number;
      granted_comment?: string;
      substitute_enabled?: boolean;
    };
    absences_cancel: { id: number };
    absences_create: {
      type_id: number;
      subtype_id?: number;
      user_id: number;
      /**
       * The user replacement for this request.
       */
      replacement_user_id?: number;
      request_comment?: string;
      from_date: string;
      to_date: string;
      duration?: number;
      /**
       * If the request ends with a partial day, the value of the last partial day.
       */
      request_partial_begin_duration?: number;
      /**
       * If the request begins with a partial day, the value of the first partial day.
       */
      request_partial_end_duration?: number;
      begin?: string;
      substitute_enabled?: boolean;
      /**
       * Arbitrary data for requests
       */
      individual_value_1?: string;
    };
    absences_read: {
      id?: number;
      type_id?: number;
      subtype_id?: number;
      user_id?: number;
      /**
       * The user replacement for this request.
       */
      replacement_user_id?: number;
      /**
       * The department id to which the request user (request_user_id) was assigned at the time of holiday request
       */
      request_user_department_id?: number;
      /**
       * The department role id to which the request user (request_user_id) was assigned at the time of holiday request
       */
      request_user_role_id?: number;
      created?: string;
      status?: number;
      granted_user_id?: number;
      granted_as_substitute_user_id?: number;
      granted_timestamp?: string;
      request_comment?: string;
      granted_comment?: string;
      from_date?: string;
      to_date?: string;
      duration?: number;
      /**
       * If the request ends with a partial day, the value of the last partial day.
       */
      request_partial_begin_duration?: number;
      /**
       * If the request begins with a partial day, the value of the first partial day.
       */
      request_partial_end_duration?: number;
      duration_unit?: string;
      begin?: string;
      substitute_enabled?: boolean;
      /**
       * Arbitrary data for requests
       */
      individual_value_1?: string;
      /**
       * If the multistage approval for this reuest is active.
       */
      is_multistage_request?: boolean;
      /**
       * The last level in the chain responsibility table (autoupdated) that is not approved yet
       */
      chain_level?: number;
      updated?: string;
    };
    absences_reject: {
      id: number;
      granted_comment?: string;
      substitute_enabled?: boolean;
    };
    absences_update: {
      id: number;
      request_comment?: string;
      substitute_enabled?: boolean;
      /**
       * Arbitrary data for requests
       */
      individual_value_1?: string;
    };
    absenceTypes_create: {
      /**
       * Id of the absence type.
       */
      absence_type_id?: number;
      /**
       * Sort order in views.
       */
      sort_order?: number;
      /**
       * Absence name.
       */
      name_const: string;
      /**
       * Absence abbrevation constant.
       */
      abbreviation_const: string;
      /**
       * If the absence is shown in the selection for user.
       */
      show_in_selection?: boolean;
      /**
       * If the users can request this absence.
       */
      enabled_for_requests?: boolean;
      /**
       * If the leave should be added to working hours.
       */
      add_to_working_hours?: boolean;
      /**
       * If 0, the the user cannot enter more time of the day of absence as the target working hour according to his working time model.
       */
      allow_tracking_more_then_target_working_hours?: boolean;
      /**
       * The possible types are WORKFLOW, USER, HR_MANAGER, MANAGER, SYSTEM
       */
      request_type?: string;
      /**
       * Whether the absence can be entered on a non working day like weekends and public holidays
       */
      allow_entry_on_non_working_days?: boolean;
      /**
       * Whether the type of absence ALWAYS will be shown in the team calendar independently of the user setting: "Show type of absence..."
       */
      public_leave_type?: boolean;
      /**
       * Whether the comment field in the application window needs to be filled out by the applicant.
       */
      comment_is_mandatory?: boolean;
      /**
       * Whether the comment field in the rejection window is mandatory or not.
       */
      reject_request_comment_is_mandatory?: boolean;
      /**
       * This JSON setting tells which days should be shown in the request window for the duration. Defaults are 0.25, 0.50, 0.75 and 1. Amounts can be added, removed or changed. The value needs to be a valid JSON string. The durations are procentual digits separated by a comma. (so for 0.10 add 10).
       */
      show_day_amount_config?: string;
      /**
       * Whether the user limitation config is enabled for this absence.
       */
      enable_user_limitations?: boolean;
      /**
       * If enable_user_limitations is enabled, the JSON config for the limitation
       */
      user_limitations_config?: string;
      /**
       * Whether to enable/disable the substitute mode for the leave type. e.g. usually during the absence home office we dont need the substitute to handle all requests.
       */
      enable_for_substitute_mode?: boolean;
      /**
       * If request_type = "USER" and the user enters an absence, a notification email will be sent to the responsible manager.
       */
      send_email_notification_to_responsible_manager?: boolean;
      /**
       * If a manager enters an absence for somebody else, this person will be notified by email of this entry.
       */
      send_email_notification_to_user_if_entered_by_manager?: boolean;
      /**
       * The HEX code for the color to be shown in the holiday planers.
       */
      color?: string;
      /**
       * If there is a country restriction for this other paid leave. The limitations are defined in pm_working_hour_other_paid_leave_to_countries.
       */
      restrict_for_country?: boolean;
      /**
       * If a replacement is needed for this absence.
       */
      absence_window_show_replacement?: boolean;
      /**
       * Datev key
       */
      datev_absence_key?: string;
      /**
       * Datev wage type id
       */
      datev_wage_type_id?: number;
      individual_value_1?: string;
      /**
       * Tells if user can edit it in app.
       */
      is_visible_for_edit?: boolean;
    };
    absenceTypes_read: {
      /**
       * Id of the absence.
       */
      id?: number;
      /**
       * Id of the absence type.
       */
      absence_type_id?: number;
      /**
       * Id of the sub absence (other paid leaves).
       */
      absence_subtype_id?: number;
      /**
       * Group of the absence defined in pm_absece_groups.
       */
      absence_group_id?: number;
      /**
       * Sort order in views.
       */
      sort_order?: number;
      /**
       * Absence name.
       */
      name_const?: string;
      /**
       * Absence abbrevation constant.
       */
      abbreviation_const?: string;
      /**
       * If the absence is shown in the selection for user.
       */
      show_in_selection?: boolean;
      /**
       * The task_id of pm_tasks_subprojects which will be used to automatically create timestamps based on the absence.
       */
      cost_acc_task_id?: number;
      /**
       * If the users can request this absence.
       */
      enabled_for_requests?: boolean;
      /**
       * If the leave should be added to working hours.
       */
      add_to_working_hours?: boolean;
      /**
       * If 0, the the user cannot enter more time of the day of absence as the target working hour according to his working time model.
       */
      allow_tracking_more_then_target_working_hours?: boolean;
      /**
       * The possible types are WORKFLOW, USER, HR_MANAGER, MANAGER, SYSTEM
       */
      request_type?: string;
      /**
       * Whether the absence can be entered on a non working day like weekends and public holidays
       */
      allow_entry_on_non_working_days?: boolean;
      /**
       * Whether the type of absence ALWAYS will be shown in the team calendar independently of the user setting: "Show type of absence..."
       */
      public_leave_type?: boolean;
      /**
       * Whether the comment field in the application window needs to be filled out by the applicant.
       */
      comment_is_mandatory?: boolean;
      /**
       * Whether the comment field in the rejection window is mandatory or not.
       */
      reject_request_comment_is_mandatory?: boolean;
      /**
       * This JSON setting tells which days should be shown in the request window for the duration. Defaults are 0.25, 0.50, 0.75 and 1. Amounts can be added, removed or changed. The value needs to be a valid JSON string. The durations are procentual digits separated by a comma. (so for 0.10 add 10).
       */
      show_day_amount_config?: string;
      /**
       * Duration unit of the absence (hours or days).
       */
      duration_unit?: string;
      /**
       * Whether the user limitation config is enabled for this absence.
       */
      enable_user_limitations?: boolean;
      /**
       * If enable_user_limitations is enabled, the JSON config for the limitation
       */
      user_limitations_config?: string;
      /**
       * Whether to enable/disable the substitute mode for the leave type. e.g. usually during the absence home office we dont need the substitute to handle all requests.
       */
      enable_for_substitute_mode?: boolean;
      /**
       * If request_type = "USER" and the user enters an absence, a notification email will be sent to the responsible manager.
       */
      send_email_notification_to_responsible_manager?: boolean;
      /**
       * If a manager enters an absence for somebody else, this person will be notified by email of this entry.
       */
      send_email_notification_to_user_if_entered_by_manager?: boolean;
      /**
       * The HEX code for the color to be shown in the holiday planers.
       */
      color?: string;
      /**
       * If there is a country restriction for this other paid leave. The limitations are defined in pm_working_hour_other_paid_leave_to_countries.
       */
      restrict_for_country?: boolean;
      /**
       * If a replacement is needed for this absence.
       */
      absence_window_show_replacement?: boolean;
      /**
       * Datev key
       */
      datev_absence_key?: string;
      individual_value_1?: string;
      /**
       * Tells if user can edit it in app.
       */
      is_visible_for_edit?: boolean;
    };
    absenceTypes_update: {
      /**
       * Id of the absence.
       */
      id: number;
      /**
       * Sort order in views.
       */
      sort_order?: number;
      /**
       * Absence name.
       */
      name_const?: string;
      /**
       * Absence abbrevation constant.
       */
      abbreviation_const?: string;
      /**
       * If the absence is shown in the selection for user.
       */
      show_in_selection?: boolean;
      /**
       * If the users can request this absence.
       */
      enabled_for_requests?: boolean;
      /**
       * If the leave should be added to working hours.
       */
      add_to_working_hours?: boolean;
      /**
       * If 0, the the user cannot enter more time of the day of absence as the target working hour according to his working time model.
       */
      allow_tracking_more_then_target_working_hours?: boolean;
      /**
       * The possible types are WORKFLOW, USER, HR_MANAGER, MANAGER, SYSTEM
       */
      request_type?: string;
      /**
       * Whether the absence can be entered on a non working day like weekends and public holidays
       */
      allow_entry_on_non_working_days?: boolean;
      /**
       * Whether the type of absence ALWAYS will be shown in the team calendar independently of the user setting: "Show type of absence..."
       */
      public_leave_type?: boolean;
      /**
       * Whether the comment field in the application window needs to be filled out by the applicant.
       */
      comment_is_mandatory?: boolean;
      /**
       * Whether the comment field in the rejection window is mandatory or not.
       */
      reject_request_comment_is_mandatory?: boolean;
      /**
       * This JSON setting tells which days should be shown in the request window for the duration. Defaults are 0.25, 0.50, 0.75 and 1. Amounts can be added, removed or changed. The value needs to be a valid JSON string. The durations are procentual digits separated by a comma. (so for 0.10 add 10).
       */
      show_day_amount_config?: string;
      /**
       * Whether the user limitation config is enabled for this absence.
       */
      enable_user_limitations?: boolean;
      /**
       * If enable_user_limitations is enabled, the JSON config for the limitation
       */
      user_limitations_config?: string;
      /**
       * Whether to enable/disable the substitute mode for the leave type. e.g. usually during the absence home office we dont need the substitute to handle all requests.
       */
      enable_for_substitute_mode?: boolean;
      /**
       * If request_type = "USER" and the user enters an absence, a notification email will be sent to the responsible manager.
       */
      send_email_notification_to_responsible_manager?: boolean;
      /**
       * If a manager enters an absence for somebody else, this person will be notified by email of this entry.
       */
      send_email_notification_to_user_if_entered_by_manager?: boolean;
      /**
       * The HEX code for the color to be shown in the holiday planers.
       */
      color?: string;
      /**
       * If there is a country restriction for this other paid leave. The limitations are defined in pm_working_hour_other_paid_leave_to_countries.
       */
      restrict_for_country?: boolean;
      /**
       * If a replacement is needed for this absence.
       */
      absence_window_show_replacement?: boolean;
      /**
       * Datev key
       */
      datev_absence_key?: string;
      individual_value_1?: string;
    };
    absenceTypesRestrictToCountries_create: {
      other_paid_leave_id: number;
      country_id: number;
      /**
       * 0: inactive (hidden) for country / 1: active for country
       */
      status: boolean;
    };
    absenceTypesRestrictToCountries_read: {
      id?: number;
      other_paid_leave_id?: number;
      country_id?: number;
      /**
       * 0: inactive (hidden) for country / 1: active for country
       */
      status?: boolean;
    };
    absenceTypesRestrictToCountries_update: {
      id: number;
      /**
       * 0: inactive (hidden) for country / 1: active for country
       */
      status: boolean;
    };
    accessCredentials_create: {
      /**
       * Access Credential textual identification.
       */
      name_const?: string;
      /**
       * Access Credentials textual description.
       */
      description_const?: string;
      /**
       * FK which indicates the Access Credentials Type. This field is important because it indicates on how to handle specific Access Credential row.
       */
      type_id?: number;
      /**
       * Field for storing a host data.
       */
      host?: string;
      /**
       * Field for storing a port data.
       */
      port?: number;
      /**
       * Field for storing a symmetrically encrypted username.
       */
      username?: string;
      /**
       * Field for storing a symmetrically encrypted password.
       */
      password?: string;
      /**
       * Field for storing a database name.
       */
      database_name?: string;
      /**
       * Field for storing mail sender name.
       */
      mail_sender_name?: string;
      /**
       * Field for storing mail sender address
       */
      mail_sender_address?: string;
      /**
       * Field for storing a symmetrically encrypted SMTP secure data.
       */
      mail_smtp_secure?: string;
      /**
       * Field for storing a symmetrically encrypted SMTP auth data.
       */
      mail_smtp_auth?: string;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    accessCredentials_read: {
      /**
       * Autoincrement ID for Access Credentials.
       */
      id?: number;
      /**
       * Access Credential textual identification.
       */
      name_const?: string;
      /**
       * Access Credentials textual description.
       */
      description_const?: string;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    accessCredentials_update: {
      /**
       * Access Credential textual identification.
       */
      name_const: string;
      /**
       * Access Credentials textual description.
       */
      description_const?: string;
      /**
       * FK which indicates the Access Credentials Type. This field is important because it indicates on how to handle specific Access Credential row.
       */
      type_id?: number;
      /**
       * Field for storing a host data.
       */
      host?: string;
      /**
       * Field for storing a port data.
       */
      port?: number;
      /**
       * Field for storing a symmetrically encrypted username.
       */
      username?: string;
      /**
       * Field for storing a symmetrically encrypted password.
       */
      password?: string;
      /**
       * Field for storing a database name.
       */
      database_name?: string;
      /**
       * Field for storing mail sender name.
       */
      mail_sender_name?: string;
      /**
       * Field for storing mail sender address
       */
      mail_sender_address?: string;
      /**
       * Field for storing a symmetrically encrypted SMTP secure data.
       */
      mail_smtp_secure?: string;
      /**
       * Field for storing a symmetrically encrypted SMTP auth data.
       */
      mail_smtp_auth?: string;
    };
    changeTimeTrackingRequests_read: {
      id?: number;
      type?: string;
      time_tracking_id?: number;
      request_user_id?: number;
      granted_user_id?: number;
      granted_as_substitute_user_id?: number;
      new_start_time?: string;
      new_end_time?: string;
      old_start_time?: string;
      old_end_time?: string;
      request_timestamp?: string;
      status?: string;
      /**
       * Comment from the user who created the request
       */
      request_user_comment?: string;
      /**
       * Comment from the user who handled the request.
       */
      granted_user_comment?: string;
      data_changed?: string;
    };
    checkpoints_read: {
      id?: number;
      name?: string;
      mon?: boolean;
      tue?: boolean;
      wed?: boolean;
      thu?: boolean;
      fri?: boolean;
      sat?: boolean;
      sun?: boolean;
      start_time?: string;
      end_time?: string;
      mandatory?: boolean;
      task_id?: number;
      allowed_days_in_future?: number;
      allowed_days_in_past?: number;
      data_changed?: string;
    };
    checkpointTrackings_create: {
      checkpoint_id: number;
      timestamp: string;
      geo_long?: number;
      geo_lat?: number;
      geo_accuracy?: number;
      notes?: string;
      timezone: string;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
    };
    checkpointTrackings_read: {
      id?: number;
      checkpoint_id?: number;
      time_tracking_id?: number;
      timestamp?: string;
      geo_long?: number;
      geo_lat?: number;
      geo_accuracy?: number;
      notes?: string;
      timezone?: string;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
      /**
       * Flag if the request was sent live (within 5 minutes) or postdated
       */
      is_live?: boolean;
      /**
       * oauth client id from token
       */
      oauth_client_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
    };
    checkpointTrackings_update: {
      id: number;
      checkpoint_id?: number;
      time_tracking_id?: number;
      timestamp?: string;
      geo_long?: number;
      geo_lat?: number;
      geo_accuracy?: number;
      notes?: string;
      timezone?: string;
    };
    clients_read: {
      id?: number;
      company_name?: string;
      active?: boolean;
      username?: string;
      address_1?: string;
      address_2?: string;
      zip?: string;
      city?: string;
      country_id?: string;
      url?: string;
      customer_number?: string;
      contact_person_salutation_id?: number;
      contact_person_firstname?: string;
      contact_person_lastname?: string;
      contact_person_department?: string;
      phone_1?: string;
      phone_2?: string;
      email_address?: string;
    };
    countries_read: { id?: number; name?: string };
    departments_read: {
      id?: number;
      department_name?: string;
      active?: boolean;
      supervisor_id?: number;
      supervisor_assistant_id?: number;
      mother_id?: number;
      view_order?: number;
      node_path?: string;
    };
    files_read: {
      id?: number;
      title?: string;
      filename?: string;
      extension?: string;
      content_type?: string;
      /**
       * Whether this file should also be stored on the filesystem
       */
      mirror_file_to_filesystem?: boolean;
      relative_url?: string;
      /**
       * Absolute URL to a stored file.
       */
      absolute_url?: string;
      path?: string;
      size?: number;
      owner?: number;
      permissions?: number;
      description?: string;
      expires?: string;
      updated?: string;
      created?: string;
    };
    generalSettings_read: {
      id?: number;
      /**
       * Column to group the settings by translation constants
       */
      group_const?: string;
      setting_type?: string;
      setting_value?: string;
      is_updatable_by_customer?: boolean;
      /**
       * Sort order for settings displayed in property grid (Settings->AccountAdministration->General settings grid). Sorting starts with 1, 0 means no sort order
       */
      sort_order?: number;
      /**
       * Datatype for the editor used in property grid (Settings->AccountAdministration->General settings grid). Values: combo, number, boolean, string. If the value is combo, its values are fetched from pm_general_settings_combo_select_values
       */
      datatype?: string;
      super_user?: boolean;
      description?: string;
      default_value?: string;
      value_range?: string;
      text?: string;
      type?: number;
      update_value?: string;
      update_query?: string;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
    };
    generalSettings_update: { id: number; setting_value?: string };
    generalSettingsChangeLog_read: {
      id?: number;
      setting_type?: string;
      old_setting_value?: string;
      new_setting_value?: string;
      /**
       * User that did the change
       */
      changed_by_user_id?: number;
      /**
       * Timestamp of change
       */
      change_timestamp?: string;
    };
    geofences_create: {
      /**
       * Name for display in UI
       */
      name: string;
      /**
       * Latitude of the geofences center point
       */
      geo_lat: number;
      /**
       * Longitude of the geofences center point
       */
      geo_long: number;
      /**
       * Radius [meters] of the geofence
       */
      radius: number;
      updated?: string;
    };
    geofences_read: {
      id?: number;
      /**
       * Name for display in UI
       */
      name?: string;
      /**
       * Latitude of the geofences center point
       */
      geo_lat?: number;
      /**
       * Longitude of the geofences center point
       */
      geo_long?: number;
      /**
       * Radius [meters] of the geofence
       */
      radius?: number;
      updated?: string;
    };
    geofences_update: {
      id: number;
      /**
       * Name for display in UI
       */
      name?: string;
      /**
       * Latitude of the geofences center point
       */
      geo_lat?: number;
      /**
       * Longitude of the geofences center point
       */
      geo_long?: number;
      /**
       * Radius [meters] of the geofence
       */
      radius?: number;
      updated?: string;
    };
    geofenceToNodes_create: {
      geofence_id: number;
      node_id: number;
      updated?: string;
    };
    geofenceToNodes_read: {
      id?: number;
      geofence_id?: number;
      node_id?: number;
      updated?: string;
    };
    geofenceToNodes_update: { id: number; node_id?: number; updated?: string };
    invoices_create: {
      invoice_number: string;
      comment: string;
      invoice_date?: string;
      payment_date?: string;
      net_revenue: number;
      cost: number;
      customer_id: number;
      status?: boolean;
    };
    invoices_read: {
      id?: number;
      invoice_number?: string;
      comment?: string;
      invoice_date?: string;
      payment_date?: string;
      net_revenue?: number;
      cost?: number;
      customer_id?: number;
      status?: boolean;
      creation_timestamp?: string;
    };
    invoices_update: {
      id: number;
      invoice_number?: string;
      comment?: string;
      invoice_date?: string;
      payment_date?: string;
      status?: boolean;
    };
    JobParams_create: {
      /**
       * Reference to the job (job_queue.id) to which this job belongs
       */
      job_id: number;
      name: string;
      value_int?: number;
      value_text?: string;
      value_double?: number;
      value_timestamp?: string;
      value_blob?: string;
    };
    JobParams_read: {
      id?: number;
      /**
       * Reference to the job (job_queue.id) to which this job belongs
       */
      job_id?: number;
      name?: string;
      value_int?: number;
      value_text?: string;
      value_double?: number;
      value_timestamp?: string;
      value_blob?: string;
    };
    JobQueues_create: {
      /**
       * name of the task. An entry for this name must exist in the "job_config" table (either for this customer or globally in pm_general.job_config).
       */
      task: string;
      /**
       * Job will be executed at given time.
       */
      run_at?: string;
      /**
       * Date on which the job was last shipped. Important for the time-tracking of the user accounts and the recognition of crashed jobs.
       */
      scheduled_at?: string;
      params: { [key: string]: any };
    };
    JobQueues_read: {
      id?: number;
      /**
       * name of the task. An entry for this name must exist in the "job_config" table (either for this customer or globally in pm_general.job_config).
       */
      task?: string;
      /**
       * internal state of the scheduler (0 = waiting, 1 = scheduled, 2 = success, 3 = failed permantently). The default value of 0 (waiting) must be used for new jobs
       */
      state?: number;
      /**
       * worker name that picked up this job
       */
      claimed_by?: string;
      /**
       * Number of previous scheduling attempts.
       */
      tries?: number;
      /**
       * Date on which the job was created. The default value uses the current time. This should also not be overwritten because it is important for the scheduling sequence after a restart.
       */
      created_at?: string;
      /**
       * Job will be executed at given time.
       */
      run_at?: string;
      /**
       * Date on which the job was last shipped. Important for the time-tracking of the user accounts and the recognition of crashed jobs.
       */
      scheduled_at?: string;
      /**
       * Date on which the job was last terminated by a worker (not necessarily successful). Good for time tracking and backoff at the Rescheduling.
       */
      completed_at?: string;
    };
    legalDocumentAcceptanceLog_create: {
      /**
       * FK which indicates legal document.
       */
      legal_document_type_id?: number;
      /**
       * Flag which indicates accepted state of log.
       */
      accepted?: boolean;
    };
    legalDocumentAcceptanceLog_read: {
      /**
       * Autoincrement PK assigned to each legal document acceptance log.
       */
      id?: number;
      /**
       * FK which indicates legal document.
       */
      legal_document_type_id?: number;
      /**
       * Flag which indicates accepted state of log.
       */
      accepted?: boolean;
      /**
       * Indicates datetime when the document is accepted.
       */
      accepted_at?: string;
      /**
       * OAuth of the client who accepted legal document.
       */
      accepted_oauth_client_id?: string;
      /**
       * Indicates who accepted the legal document.
       */
      accepted_by_user_id?: number;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    legalDocuments_read: {
      /**
       * Autoincrement PK assigned to each legal document.
       */
      id?: number;
      /**
       * FK which indicates legal document type.
       */
      legal_document_type_id?: number;
      /**
       * Indicates the language of the legal document.
       */
      language_id?: number;
      /**
       * Version name of the legal document.
       */
      name_const?: string;
      /**
       * ID which indicates file related to this legal document.
       */
      file_id?: number;
      /**
       * Flag which defines if this document is the latest version.
       */
      latest_version?: boolean;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    legalDocumentTypes_read: {
      /**
       * Autoincrement PK assigned to each legal document type.
       */
      id?: number;
      /**
       * Legal document type textual identification.
       */
      name_const?: string;
      /**
       * Defines if this document has to be accepted by users.
       */
      acceptance_required?: boolean;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    messages_create: {
      sender_id: number;
      message: string;
      receiver_type?: string;
      receiver_id?: number;
      include_sub_department?: boolean;
      timestamp?: string;
    };
    messages_read: {
      id?: number;
      sender_id?: number;
      message?: string;
      receiver_type?: string;
      receiver_id?: number;
      include_sub_department?: boolean;
      data_changed?: string;
      timestamp_update?: string;
      timestamp?: string;
    };
    messages_update: {
      id: number;
      sender_id?: number;
      message?: string;
      receiver_type?: string;
      receiver_id?: number;
      include_sub_department?: boolean;
      timestamp?: string;
    };
    multiuserToTasks_create: { task_id: number; multiuser_id: number };
    multiuserToTasks_read: { task_id?: number; multiuser_id?: number };
    multiuserToUsers_read: { assigned_user_id?: number; user_id?: number };
    nfcTransponder_create: {
      mode_id: number;
      unique_id: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
    };
    nfcTransponder_read: {
      id?: number;
      mode_id?: number;
      unique_id?: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      created?: string;
      data_changed?: string;
    };
    nfcTransponder_update: {
      id: number;
      mode_id?: number;
      unique_id?: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
    };
    nfcTransponders_create: {
      mode_id: number;
      unique_id: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
    };
    nfcTransponders_read: {
      id?: number;
      mode_id?: number;
      unique_id?: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      created?: string;
      data_changed?: string;
    };
    nfcTransponders_update: {
      id: number;
      mode_id?: number;
      unique_id?: string;
      user_id?: number;
      task_id?: number;
      start_task_afterwards?: number;
      project_id?: number;
      checkpoint_id?: number;
      skill_id?: number;
    };
    nodesToUsers_read: {
      node?: number;
      user?: number;
      is_favourite?: boolean;
      is_todo?: boolean;
      access?: boolean;
      /**
       * Specifies a date from which on the user should be granted access
       */
      access_start?: string;
      /**
       * Specifies a date from which on the access should be revoked
       */
      access_end?: string;
      /**
       * Specifies the start date for a bookable timeframe
       */
      allow_tracking_from?: string;
      /**
       * Specifies the end date for a bookable timeframe
       */
      allow_tracking_to?: string;
      last_started?: string;
      target_duration?: number;
      revenue_per_hour?: number;
    };
    nodesToUsers_update: {
      is_favourite?: boolean;
      is_todo?: boolean;
      access?: boolean;
      /**
       * Specifies a date from which on the user should be granted access
       */
      access_start?: string;
      /**
       * Specifies a date from which on the access should be revoked
       */
      access_end?: string;
      /**
       * Specifies the start date for a bookable timeframe
       */
      allow_tracking_from?: string;
      /**
       * Specifies the end date for a bookable timeframe
       */
      allow_tracking_to?: string;
      target_duration?: number;
      revenue_per_hour?: number;
    };
    notifications_read: {
      id?: number;
      user_id?: number;
      notification_type?: number;
      is_response?: boolean;
      notification_timestamp?: string;
      status?: number;
      assoc_id?: number;
      user_id_sender?: number;
      user_id_responder?: number;
      processed?: boolean;
      email_send_status?: number;
      email_send_timestamp?: string;
      executable_1_id?: number;
      executable_2_id?: number;
      data_changed?: string;
    };
    notifications_update: { id: number; processed?: boolean };
    notificationsTypeHtml_read: {
      id?: number;
      created?: string;
      status?: boolean;
      title?: string;
      /**
       * The title for email (subject), if empty, the notification title will be used
       */
      email_subject?: string;
      /**
       * The footer for email, if empty, only the greeting will be shown.
       */
      email_footer?: string;
      content?: string;
      recipient?: number;
      sender?: number;
      content_css_class?: string;
      content_css_styles?: string;
      /**
       * If this notification will be sent over email with notification manager.
       */
      send_mail_per_email_notification_manager?: boolean;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
    };
    notificationUrls_read: {
      id?: number;
      headline?: string;
      url?: string;
      /**
       * Timestamp of last change
       */
      data_changed?: string;
    };
    offlineSyncError_read: { id?: number; user_id?: number; error?: string };
    offlineSyncErrors_read: { id?: number; user_id?: number; error?: string };
    permissionResolveAbsenceTypesAndUsers_read: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Absence id on which subject_user_id has some permission
       */
      resolve_absence_type_id?: number;
      /**
       * Absence subtype id on which subject_user_id has some permission
       */
      resolve_absence_subtype_id?: number;
      /**
       * User id on which subject_user_id has some permission
       */
      resolve_user_id?: number;
      /**
       * If subject_user_id have permissions for all absences then we will use wildcard. (e.g. * )
       */
      resolve_absence_type_wildcard?: string;
      /**
       * If subject_user_id have permissions for all subtypes of one absence type then we will use wildcard. (e.g. * )
       */
      resolve_absence_subtype_wildcard?: string;
      /**
       * If subject_user_id have permissions for all users then we will use wildcard. (e.g. * )
       */
      resolve_user_wildcard?: string;
      /**
       * User ids from which permission is inherited
       */
      inherited_user_ids?: string;
    };
    permissionResolveDepartments_read: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Department id on which subject_user_id has some permission
       */
      resolve_department_id?: number;
      /**
       * If subject_user_id have permissions for all users in department then we will use wildcard. (e.g. * )
       */
      resolve_department_wildcard?: string;
    };
    permissionResolveHolidayRequests_read: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Holiday request id on which subject_user_id has some permission
       */
      resolve_holiday_request_id?: number;
    };
    permissionResolveOauthClients_read: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * oauth_client id on which subject_user_id has some permission
       */
      resolve_oauth_client_id?: number;
      /**
       * If subject_user_id have permissions for all oauth_clients then we will use wildcard. (e.g. * )
       */
      resolve_oauth_client_wildcard?: string;
    };
    permissionResolveQuestions_read: {
      id?: number;
      question_name?: string;
      question_description?: string;
      /**
       * Which endpoint should be called to get answer for this question
       */
      question_endpoint?: string;
    };
    permissionResolveTeams_read: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * Team id on which subject_user_id has some permission
       */
      resolve_team_id?: number;
      /**
       * If subject_user_id have permissions for all teams then we will use wildcard. (e.g. * )
       */
      resolve_team_wildcard?: string;
    };
    permissionResolveUsers_read: {
      id?: number;
      /**
       * Question id from pm_acl_tt_resolve_questions
       */
      resolve_question_id?: number;
      /**
       * For which user we are resolving question
       */
      subject_user_id?: number;
      /**
       * User id on which subject_user_id has some permission
       */
      resolve_user_id?: number;
      /**
       * If subject_user_id have permissions for all users then we will use wildcard. (e.g. * )
       */
      resolve_user_wildcard?: string;
      /**
       * User ids from which permission is inherited
       */
      inherited_user_ids?: string;
    };
    permissions_read: {
      id?: number;
      user_id?: number;
      resource_name?: string;
      permission_name?: string;
      permission_scope_id?: number;
      permission_scope_data_1?: number;
      permission_scope_data_2?: number;
      permission_scope_data_3?: number;
    };
    permissionScopes_read: {
      id?: number;
      name?: string;
      string_definition?: string;
    };
    projects_create: {
      mother_id: number;
      sort_order?: number;
      name: string;
      is_done?: boolean;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      is_restricted?: boolean;
      project_leader_id?: number;
      budget?: number;
      last_started?: string;
    };
    projects_read: {
      id?: number;
      mother_id?: number;
      view_id?: string;
      sort_order?: number;
      node_path?: string;
      ultimate_mother_id?: number;
      name?: string;
      is_done?: boolean;
      view_order?: number;
      icon_name?: string;
      initial_duration?: number;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      object_type?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      duration?: number;
      is_restricted?: boolean;
      project_leader_id?: number;
      budget?: number;
      last_started?: string;
    };
    projects_update: {
      id: number;
      mother_id?: number;
      sort_order?: number;
      name?: string;
      is_done?: boolean;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      is_restricted?: boolean;
      project_leader_id?: number;
      budget?: number;
      last_started?: string;
    };
    PublicHolidayTemplates_read: {
      id?: number;
      mother_id?: number;
      template_name?: string;
    };
    salutations_read: { id?: number; const?: string; gender?: string };
    schedulings_read: {
      id?: number;
      user_id?: number;
      task_id?: number;
      start_date?: string;
      end_date?: string;
      note?: string;
      /**
       * User id of the user that created the schedule.
       */
      created_user_id?: number;
      /**
       * Datetime of when the entry was created.
       */
      created?: string;
      /**
       * User id of the user that changed the schedule.
       */
      change_user_id?: number;
      /**
       * Datetime of when the entry was changed.
       */
      data_changed?: string;
    };
    serverEvents_read: {
      id?: number;
      /**
       * User id if server event is supposed to be triggered for specific user
       */
      user_id?: number;
      key?: string;
      /**
       * The value that the key should hold
       */
      value?: string;
    };
    skills_read: {
      id?: number;
      syn?: string;
      sort_order?: number;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      rillsoft_id?: string;
    };
    surveyAnswers_create: {
      /**
       * FK to pm_user_user_settings.administrators_id which indicates a user who submitted an answer.
       */
      user_id: number;
      /**
       * FK which links this answer to a specific submit. This is very important, since it is the only mechanism to group multiple answers from a single submit.
       */
      survey_submit_id: number;
      /**
       * FK which links this answer to a specific question. Combined with survey_submit_id these fields are representing specific answer related to specific submit.
       */
      question_id: number;
      /**
       * This represents integer value of an answer, which is carried over from pm_survey_question_definitions.value. If we need text representation for this answer it can be found at pm_survey_question_definitions.name_const
       */
      value: number;
      /**
       * This represents textual value entered by user (in the cases where answer can be textual value). This field DOES NOT take values from pm_survey_question_definitions.name_const
       */
      value_text?: string;
      /**
       * This field defines a creation date of an answer.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveyAnswers_read: {
      /**
       * PK for survey answer.
       */
      id?: number;
      /**
       * FK to pm_user_user_settings.administrators_id which indicates a user who submitted an answer.
       */
      user_id?: number;
      /**
       * FK which links this answer to a specific submit. This is very important, since it is the only mechanism to group multiple answers from a single submit.
       */
      survey_submit_id?: number;
      /**
       * FK which links this answer to a specific question. Combined with survey_submit_id these fields are representing specific answer related to specific submit.
       */
      question_id?: number;
      /**
       * Department id of the user who created an answer
       */
      department_id?: number;
      /**
       * This represents integer value of an answer, which is carried over from pm_survey_question_definitions.value. If we need text representation for this answer it can be found at pm_survey_question_definitions.name_const
       */
      value?: number;
      /**
       * This represents textual value entered by user (in the cases where answer can be textual value). This field DOES NOT take values from pm_survey_question_definitions.name_const
       */
      value_text?: string;
      /**
       * This field defines a creation date of an answer.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveyAnswers_update: {
      /**
       * PK for survey answer.
       */
      id?: number;
      /**
       * FK to pm_user_user_settings.administrators_id which indicates a user who submitted an answer.
       */
      user_id: number;
      /**
       * FK which links this answer to a specific submit. This is very important, since it is the only mechanism to group multiple answers from a single submit.
       */
      survey_submit_id: number;
      /**
       * FK which links this answer to a specific question. Combined with survey_submit_id these fields are representing specific answer related to specific submit.
       */
      question_id: number;
      /**
       * This represents integer value of an answer, which is carried over from pm_survey_question_definitions.value. If we need text representation for this answer it can be found at pm_survey_question_definitions.name_const
       */
      value?: number;
      /**
       * This represents textual value entered by user (in the cases where answer can be textual value). This field DOES NOT take values from pm_survey_question_definitions.name_const
       */
      value_text?: string;
      /**
       * This field defines a creation date of an answer.
       */
      created_at?: string;
    };
    surveyQuestionDefinitions_read: {
      /**
       * PK for question definitions. Question definitions are important since they are representing the POTENTIAL answers.
       */
      id?: number;
      /**
       * FK which indicates the actual question to whom definitions are related. Basically, in terms of frontend, if question is LIST, then question_definitions are the LIST-ITEMS.
       */
      survey_question_id?: number;
      /**
       * Integer value for the question definition. This field is mandatory and important in terms of answers and further calculations.
       */
      value?: number;
      /**
       * This is textual value that can be assigned to a question definition value. It is descriptive and it wont affect calculations, but it might be used as a search pattern.
       */
      name_const?: string;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveyQuestions_read: {
      /**
       * PK for the survey question. Question is basically a placeholder for a possible answers, which we keep in the table pm_survey_question_definitions.
       */
      id?: number;
      /**
       * FK which indicates to which survey is this question related.
       */
      survey_id?: number;
      /**
       * This field is used to store the actual question (in a short form).
       */
      name_const?: string;
      /**
       * Description is used if question needs further explanation. For example, some questions holds explanations for the users on how to properly answer. Data like this should be stored in here.
       */
      description_const?: string;
      /**
       * Summary type defines a way to handle summaries for survey statistics.
       */
      summary_type_id?: number;
      /**
       * If 1 avg results of question are shown in grid_user_statistics
       */
      show_results_in_grid_user_statistics?: boolean;
      /**
       * If 1 avg results of question are shown in grid_department_statistics
       */
      show_results_in_grid_department_statistics?: boolean;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveys_read: {
      /**
       * Autoincrement PK for survey.
       */
      id?: number;
      /**
       * Survey textual identification.
       */
      name_const?: string;
      /**
       * Additional information about a survey.
       */
      description_const?: string;
      /**
       * Indicates if a survey is locked. If the survey is locked (locked = 1) it is not possible to change questions related to this survey. Default value is 0 which indicates that survey is still under the construction (SAVED or DRAFTED). Once a survey has been PUBLISHED this status is switching to locked = 1 and it stays like this permanently.
       */
      locked?: boolean;
      /**
       * This indicates if survey is open for a answers (i.e. survey can be published but inactive). Only when active = 1, new answers can be created. This status can change in time, so the survey can be active/inactive in different timeframes, allowing flexibility.
       */
      active?: boolean;
      /**
       * FK which indicates survey vote cycle. This field is very important because it defines if user answer UPDATES existing one or counts as a new INSERT.
       */
      vote_cycle_id?: number;
      /**
       * Indicates creator of a survey. This is not a FK because there is no creator if system survey exists.
       */
      creator_user_id?: number;
      /**
       * Datetime for creation date, generated by the backend.
       */
      created_at?: string;
      /**
       * Timestamp for update date.
       */
      updated_at?: string;
    };
    surveySubmits_create: {
      /**
       * Timestamp which defines actual survey submit date/time.
       */
      created_at?: string;
    };
    surveySubmits_submit: {
      /**
       * PK for survey submits. Survey submit represents one event (REQUEST) when user clicked button submit.
       */
      id?: number;
      /**
       * Timestamp which defines actual survey submit date/time.
       */
      created_at?: string;
    };
    surveySubmits_update: {
      /**
       * PK for survey submits. Survey submit represents one event (REQUEST) when user clicked button submit.
       */
      id?: number;
      /**
       * Timestamp which defines actual survey submit date/time.
       */
      created_at?: string;
    };
    tasks_create: {
      mother_id: number;
      sort_order?: number;
      name: string;
      is_done?: boolean;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      is_startable?: boolean;
      is_billable?: boolean;
      is_nonworking?: boolean;
      is_paid_non_working?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      skill_id?: number;
      priority?: number;
      is_favourite?: boolean;
      is_todo?: boolean;
      last_started?: string;
    };
    tasks_read: {
      id?: number;
      mother_id?: number;
      view_id?: string;
      sort_order?: number;
      node_path?: string;
      ultimate_mother_id?: number;
      name?: string;
      is_done?: boolean;
      view_order?: number;
      icon_name?: string;
      initial_duration?: number;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      object_type?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      duration?: number;
      is_startable?: boolean;
      is_billable?: boolean;
      is_nonworking?: boolean;
      is_paid_non_working?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      skill_id?: number;
      priority?: number;
      is_favourite?: boolean;
      is_todo?: boolean;
      last_started?: string;
    };
    tasks_update: {
      id: number;
      mother_id?: number;
      sort_order?: number;
      name?: string;
      is_done?: boolean;
      target_duration?: number;
      begin?: string;
      deadline?: string;
      notes?: string;
      client_id?: number;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      approve_by_project_leader?: boolean;
      is_blocked?: boolean;
      is_hidden?: boolean;
      restrict_tracking_from_to?: boolean;
      is_startable?: boolean;
      is_billable?: boolean;
      is_nonworking?: boolean;
      is_paid_non_working?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      skill_id?: number;
      priority?: number;
      is_favourite?: boolean;
      is_todo?: boolean;
      last_started?: string;
    };
    teamMembers_create: { team_id: number; user_id: number };
    teamMembers_read: { team_id?: number; user_id?: number };
    teams_create: {
      name: string;
      team_leader_id: number;
      /**
       * Foreign key to map pm_task_subprojects relations
       */
      project_id?: number;
    };
    teams_read: {
      id?: number;
      name?: string;
      team_leader_id?: number;
      /**
       * Foreign key to map pm_task_subprojects relations
       */
      project_id?: number;
      data_changed?: string;
      /**
       * Concanated string of all the members
       */
      current_team_members?: string;
      /**
       * TTW-2805: do not change manually - column changes automatically to 1 if there are entries in  pm_user_with_teamplaner_access
       */
      use_pm_user_with_teamplaner_access_table?: boolean;
      /**
       * TTW-2805: do not change manually - column changes automatically to 1 if there are entries in  pm_user_with_teamplaner_access
       */
      current_user_with_teamplaner_access?: string;
    };
    teams_update: {
      id: number;
      name?: string;
      team_leader_id?: number;
      /**
       * Foreign key to map pm_task_subprojects relations
       */
      project_id?: number;
    };
    timePlannings_create: {
      user_id: number;
      task_id: number;
      start_time: string;
      end_time: string;
      status?: number;
      notes?: string;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      u_iv_1?: string;
      u_iv_2?: string;
      u_iv_3?: string;
      u_iv_4?: string;
      u_iv_5?: string;
      u_iv_6?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone: string;
    };
    timePlannings_read: {
      id?: number;
      user_id?: number;
      task_id?: number;
      scheduling_id?: number;
      shift_id?: number;
      /**
       * The recurring element this planning entry belongs to
       */
      recurring_elements_id?: number;
      department_node_path?: string;
      /**
       * The department id to which the timeplannings user (pm_time_planning.user_id) was assigned at the time start_date of the timePlanning.
       */
      department_id?: number;
      /**
       * The department role id to which the timeplannings user (pm_time_planning.user_id) was assigned at the time start_date of the timePlanning.
       */
      department_role_id?: number;
      task_node_path?: string;
      project_leader_id?: number;
      is_nonworking?: boolean;
      skill_id?: number;
      client_id?: number;
      year?: number;
      yearmonth?: string;
      month?: number;
      start_date?: string;
      start_time?: string;
      end_time?: string;
      duration?: number;
      status?: number;
      cost_user?: number;
      cost_task?: number;
      revenue_user?: number;
      revenue_task?: number;
      push_trigger?: string;
      is_billable?: boolean;
      notes?: string;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      u_iv_1?: string;
      u_iv_2?: string;
      u_iv_3?: string;
      u_iv_4?: string;
      u_iv_5?: string;
      u_iv_6?: string;
      cost_acc_type?: string;
      is_paid_non_working?: boolean;
      /**
       * Has a timestamp been created in the cronjob.
       */
      timestamp_created?: boolean;
      /**
       * User id of the user that created the time planning.
       */
      created_user_id?: number;
      /**
       * Datetime of when the entry was created.
       */
      created?: string;
      /**
       * User id of the user that changed the entry.
       */
      change_user_id?: number;
      data_changed?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
    };
    timePlannings_update: {
      id: number;
      task_id?: number;
      start_time?: string;
      end_time?: string;
      status?: number;
      notes?: string;
      t_iv_1?: string;
      t_iv_2?: string;
      t_iv_3?: string;
      t_iv_4?: string;
      t_iv_5?: string;
      t_iv_6?: string;
      u_iv_1?: string;
      u_iv_2?: string;
      u_iv_3?: string;
      u_iv_4?: string;
      u_iv_5?: string;
      u_iv_6?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
    };
    timesheetAccountings_read: {
      id?: number;
      user_id?: number;
      department_id?: number;
      /**
       * The department role id to which the user (user_id) was assigned at the time of timesheetAccounting
       */
      user_role_id?: number;
      date?: string;
      approved_by_user?: boolean;
      approved_by_admin?: boolean;
      approved_by_user_1?: boolean;
      ordinary_hours?: number;
      target_working_hours?: number;
      begin_time?: string;
      end_time?: string;
      break?: number;
      flexible_working_time?: number;
      core_working_time?: number;
      working_time?: number;
      /**
       * Planned time of day
       */
      working_time_planned?: number;
      user_defined_time_1?: number;
      user_defined_time_2?: number;
      user_defined_time_3?: number;
      user_defined_time_4?: number;
      user_defined_time_5?: number;
      user_defined_time_6?: number;
      user_defined_time_7?: number;
      user_defined_time_8?: number;
      excess_work?: number;
      excess_work_consumption?: number;
      excess_work_adjustments?: number;
      excess_work_balance?: number;
      overtime_1?: number;
      overtime_1_consumption?: number;
      overtime_1_adjustments?: number;
      overtime_1_balance?: number;
      overtime_2?: number;
      overtime_2_consumption?: number;
      overtime_2_adjustments?: number;
      overtime_2_balance?: number;
      overtime_3?: number;
      overtime_3_consumption?: number;
      overtime_3_adjustments?: number;
      overtime_3_balance?: number;
      overtime_4?: number;
      overtime_4_consumption?: number;
      overtime_4_adjustments?: number;
      overtime_4_balance?: number;
      overtime_5?: number;
      overtime_5_consumption?: number;
      overtime_5_adjustments?: number;
      overtime_5_balance?: number;
      overtime_6?: number;
      overtime_6_consumption?: number;
      overtime_6_adjustments?: number;
      overtime_6_balance?: number;
      total_working_time?: number;
      paid_nonworking_time?: number;
      paid_nonworking_time_set_by_user?: number;
      total_working_time_incl_paid_non_working_time?: number;
      working_time_daily_balance?: number;
      working_time_daily_balance_incl_standby?: number;
      additions?: number;
      overtime_allowance?: number;
      overtime_paid?: number;
      overtime_reduction?: number;
      working_time_total_balance?: number;
      public_holiday?: number;
      holiday?: number;
      holiday_adjustments?: number;
      holiday_balance?: number;
      tmp_holiday_balance?: number;
      sick_leave?: number;
      sick_leave_adjustments?: number;
      sick_leave_balance?: number;
      other_paid_leave?: number;
      other_paid_leave_id?: number;
      user_defined_day_1?: number;
      user_defined_day_1_adjustments?: number;
      user_defined_day_1_balance?: number;
      user_defined_day_2?: number;
      user_defined_day_2_adjustments?: number;
      user_defined_day_2_balance?: number;
      user_defined_day_3?: number;
      user_defined_day_3_adjustments?: number;
      user_defined_day_3_balance?: number;
      user_defined_day_4?: number;
      user_defined_day_5?: number;
      user_defined_day_6?: number;
      user_defined_day_7?: number;
      user_defined_day_8?: number;
      comment?: string;
      data_changed?: string;
      break_law_check?: number;
      workday?: boolean;
      weekday?: number;
      /**
       * Meant to allow grouping by year
       */
      year?: number;
      /**
       * Meant to allow grouping by month
       */
      month?: number;
      /**
       * Meant to allow grouping by week
       */
      week?: number;
    };
    timesheetAccountingSummaries_read: { user_id: number };
    timesheetActionLogs_read: {
      id?: number;
      user_id?: number;
      /**
       * The department id to which the user (user_id) was assigned at the time of absenceDay
       */
      user_department_id?: number;
      /**
       * The department role id to which the user (user_id) was assigned at the time of absenceDay
       */
      user_role_id?: number;
      date?: string;
      type?: string;
      other_paid_leave_id?: number;
      value?: number;
      value_unit?: string;
      request_id?: number;
      /**
       * Reflects the status from pm_holiday_requests (absence).
       */
      status?: number;
      comment?: string;
      begin?: string;
      updated?: string;
    };
    timeTrackingChangelogs_read: {
      id?: number;
      change_timestamp?: string;
      change_type?: string;
      /**
       * Change reason: 0 - default, 1 - Automatic Brake, 2 - Round Timers
       */
      change_reason_id?: number;
      /**
       * logged in user_id at change time
       */
      change_user_id?: number;
      tracker_id?: number;
      user_id?: number;
      task_id?: number;
      start_time?: string;
      /**
       * The new start time of the timestamp
       */
      new_start_time?: string;
      end_time?: string;
      /**
       * The new end time of the timestamp
       */
      new_end_time?: string;
      duration?: number;
    };
    timeTrackings_approve: { id: number };
    timeTrackings_create: {
      user_id: number;
      task_id: number;
      start_time: string;
      end_time: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone: string;
      max_hours_alert?: boolean;
      t_iv_1?: string;
      /**
       * if 1, admin has approved time tracking entry (no change possible)
       */
      approved_by_admin?: boolean;
      geo_start_lat?: number;
      geo_start_long?: number;
      geo_start_accuracy?: number;
      geo_end_lat?: number;
      geo_end_long?: number;
      geo_end_accuracy?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timeTrackings_current: {
      id?: number;
      user_id?: number;
      task_id?: number;
      start_time?: string;
      end_time?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
      duration?: number;
      status?: number;
      start_ip?: string;
      end_ip?: string;
      max_hours_alert?: boolean;
      input_type?: number;
      t_iv_1?: string;
      /**
       * if 1, admin has approved time tracking entry (no change possible)
       */
      approved_by_admin?: boolean;
      geo_start_lat?: number;
      geo_start_long?: number;
      geo_start_accuracy?: number;
      geo_end_lat?: number;
      geo_end_long?: number;
      geo_end_accuracy?: number;
      updated?: string;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timeTrackings_read: {
      id?: number;
      user_id?: number;
      /**
       * The department id to which the timetrackings user (pm_time_tracking.user_id) was assigned at the time start_date of the timeTracking.
       */
      department_id?: number;
      /**
       * The department role id to which the timetrackings user (pm_time_tracking.user_id) was assigned at the time start_date of the timeTracking.
       */
      department_role_id?: number;
      task_id?: number;
      start_time?: string;
      end_time?: string;
      start_time_offset?: number;
      end_time_offset?: number;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
      /**
       * Whether the start of the timer was booked live or not
       */
      is_start_live?: boolean;
      /**
       * Whether the end of the timer was booked live or not
       */
      is_end_live?: boolean;
      duration?: number;
      status?: number;
      start_ip?: string;
      end_ip?: string;
      is_statistic_countable?: boolean;
      max_hours_alert?: boolean;
      input_type?: number;
      t_iv_1?: string;
      /**
       * if 1, admin has approved time tracking entry (no change possible)
       */
      approved_by_admin?: boolean;
      geo_start_lat?: number;
      geo_start_long?: number;
      geo_start_accuracy?: number;
      geo_end_lat?: number;
      geo_end_long?: number;
      geo_end_accuracy?: number;
      updated?: string;
      /**
       * Id of latest time tracking change request
       */
      last_change_time_tracking_request_id?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timeTrackings_reject: { id: number };
    timeTrackings_split: {
      id: number;
      task_id?: number;
      timezone: string;
      time: string;
      max_hours_alert?: boolean;
      t_iv_1?: string;
      geo_lat?: number;
      geo_long?: number;
      geo_accuracy?: number;
    };
    timeTrackings_start: {
      user_id: number;
      task_id?: number;
      start_time?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      t_iv_1?: string;
      geo_start_lat?: number;
      geo_start_long?: number;
      geo_start_accuracy?: number;
      /**
       * Special unique case: If a to-be-inserted value is not null and exists already, the create action should successfully return the existing row instead of creating (and no unique error)
       */
      client_unique_id?: string;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timeTrackings_stop: {
      user_id: number;
      end_time?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone: string;
      t_iv_1?: string;
      geo_end_lat?: number;
      geo_end_long?: number;
      geo_end_accuracy?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timeTrackings_toggle: {
      user_id: number;
      task_id?: number;
      timezone: string;
      time?: string;
      t_iv_1?: string;
      geo_lat?: number;
      geo_long?: number;
      geo_accuracy?: number;
    };
    timeTrackings_update: {
      id: number;
      task_id?: number;
      start_time?: string;
      end_time?: string;
      /**
       * Timezone, eg. Europe/Vienna, that is mandatory if action is CREATE
       */
      start_time_timezone?: string;
      /**
       * Timezone needs to be set if end_time field value is set
       */
      end_time_timezone?: string;
      max_hours_alert?: boolean;
      t_iv_1?: string;
      /**
       * if 1, admin has approved time tracking entry (no change possible)
       */
      approved_by_admin?: boolean;
      geo_start_lat?: number;
      geo_start_long?: number;
      geo_start_accuracy?: number;
      geo_end_lat?: number;
      geo_end_long?: number;
      geo_end_accuracy?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      start_type_id?: number;
      /**
       * 0 = post-dated, 1 = live, 2 = nfc
       */
      end_type_id?: number;
    };
    timezones_read: { id?: number; timezone?: string };
    translations_read: { translation_key?: string; value?: string };
    userDefinedFieldDefinitionOptions_read: {
      id?: number;
      field_id?: string;
      field_option_id?: number;
      field_option_value?: string;
      /**
       * When active is set to 0, the option disabled in the combo.
       */
      active?: boolean;
      /**
       * Sort order of user defined field if combobox.
       */
      sort_order?: number;
    };
    userDefinedFieldDefinitions_read: {
      id?: string;
      entity?: string;
      fieldname?: string;
      fieldtype?: string;
      aggregation_type?: string;
    };
    users_create: {
      active?: boolean;
      department_id: number;
      start_task_at_login?: number;
      username: string;
      personnel_number?: string;
      lastname: string;
      firstname: string;
      abbrevation?: string;
      restrict_to_ip?: boolean;
      permission_show_tt_ex_post_one_employees?: boolean;
      permission_show_assign_favourites?: boolean;
      permission_show_assign_todos?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      password: string;
      email_address?: string;
      language_id: number;
      phone?: string;
      skype?: string;
      profile_picture?: string;
      u_iv_1?: string;
      u_iv_1_valid_from?: string;
      u_iv_2?: string;
      u_iv_2_valid_from?: string;
      u_iv_3?: string;
      u_iv_3_valid_from?: string;
      u_iv_4?: string;
      u_iv_4_valid_from?: string;
      u_iv_5?: string;
      u_iv_5_valid_from?: string;
      u_iv_6?: string;
      u_iv_6_valid_from?: string;
      mobile_allowed?: boolean;
      pin_code?: string;
      country_id?: number;
      allowed_ips?: string;
      payroll_accounting_starts_at?: string;
      payroll_accounting_initial_value_working_time_total_balance?: number;
      public_holiday_template_id: number;
      manual_timetracking?: boolean;
      automatic_tracker_writing_task_id?: number;
      cost_acc_non_working_task_id?: number;
      phone_1?: string;
      phone_2?: string;
      birthday?: string;
      entry_date?: string;
      exit_date?: string;
      notes?: string;
      social_security_number?: string;
      address_1?: string;
      address_2?: string;
      zip?: string;
      permission_show_edit_user_user_settings?: boolean;
      terminal_transponder_nr?: string;
      external_id?: string;
      company_name?: string;
      timesheet_template_id?: number;
      timesheet_template_id_valid_starting_from?: string;
      timesheet_holiday_calc_yearly_amount?: number;
      timesheet_holiday_calc_starting_from?: string;
      timesheet_holiday_calc_interval_mode?: string;
      working_time_balance_rule?: number;
      working_time_balance_rule_valid_from?: string;
      overtime_allowance_included_overtime_hours_per_cycle?: number;
      payroll_accounting_initial_value_holiday?: number;
      timetac_product_id?: number;
      leave_note?: string;
      request_substitute_user_id?: number;
      time_tracking_ex_post_earliest_working_time?: string;
    };
    users_read: {
      id?: number;
      active?: boolean;
      department_id?: number;
      department_id_valid_from?: string;
      role_id?: number;
      start_task_at_login?: number;
      username?: string;
      personnel_number?: string;
      lastname?: string;
      firstname?: string;
      fullname?: string;
      abbrevation?: string;
      restrict_to_ip?: boolean;
      permission_show_tt_ex_post_one_employees?: boolean;
      permission_show_assign_favourites?: boolean;
      permission_show_assign_todos?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      email_address?: string;
      language_id?: number;
      phone?: string;
      skype?: string;
      profile_picture?: string;
      u_iv_1?: string;
      u_iv_1_valid_from?: string;
      u_iv_2?: string;
      u_iv_2_valid_from?: string;
      u_iv_3?: string;
      u_iv_3_valid_from?: string;
      u_iv_4?: string;
      u_iv_4_valid_from?: string;
      u_iv_5?: string;
      u_iv_5_valid_from?: string;
      u_iv_6?: string;
      u_iv_6_valid_from?: string;
      mobile_allowed?: boolean;
      country_id?: number;
      allowed_ips?: string;
      payroll_accounting_starts_at?: string;
      payroll_accounting_initial_value_working_time_total_balance?: number;
      public_holiday_template_id?: number;
      public_holiday_template_id_valid_from?: string;
      manual_timetracking?: boolean;
      automatic_tracker_writing_task_id?: number;
      cost_acc_non_working_task_id?: number;
      phone_1?: string;
      phone_2?: string;
      birthday?: string;
      entry_date?: string;
      exit_date?: string;
      notes?: string;
      social_security_number?: string;
      address_1?: string;
      address_2?: string;
      zip?: string;
      permission_show_edit_user_user_settings?: boolean;
      terminal_transponder_nr?: string;
      external_id?: string;
      company_name?: string;
      timesheet_template_id?: number;
      timesheet_template_id_valid_starting_from?: string;
      timesheet_holiday_calc_yearly_amount?: number;
      timesheet_holiday_calc_starting_from?: string;
      timesheet_holiday_calc_interval_mode?: string;
      working_time_balance_rule?: number;
      working_time_balance_rule_valid_from?: string;
      overtime_allowance_included_overtime_hours_per_cycle?: number;
      payroll_accounting_initial_value_holiday?: number;
      timetac_product_id?: number;
      enable_module_employee_timetracking?: boolean;
      enable_module_project_timetracking?: boolean;
      enable_module_leave_management?: boolean;
      enable_module_shift_planning?: boolean;
      leave_note?: string;
      request_substitute_user_id?: number;
      time_tracking_ex_post_earliest_working_time?: string;
    };
    users_resetPassword: { id?: number; username?: string };
    users_update: {
      id: number;
      active?: boolean;
      department_id?: number;
      department_id_valid_from?: string;
      role_id?: number;
      start_task_at_login?: number;
      username?: string;
      personnel_number?: string;
      lastname?: string;
      firstname?: string;
      abbrevation?: string;
      restrict_to_ip?: boolean;
      permission_show_tt_ex_post_one_employees?: boolean;
      permission_show_assign_favourites?: boolean;
      permission_show_assign_todos?: boolean;
      internal_cost_per_hour?: number;
      revenue_per_hour?: number;
      password?: string;
      email_address?: string;
      language_id?: number;
      phone?: string;
      skype?: string;
      profile_picture?: string;
      u_iv_1?: string;
      u_iv_1_valid_from?: string;
      u_iv_2?: string;
      u_iv_2_valid_from?: string;
      u_iv_3?: string;
      u_iv_3_valid_from?: string;
      u_iv_4?: string;
      u_iv_4_valid_from?: string;
      u_iv_5?: string;
      u_iv_5_valid_from?: string;
      u_iv_6?: string;
      u_iv_6_valid_from?: string;
      mobile_allowed?: boolean;
      pin_code?: string;
      country_id?: number;
      allowed_ips?: string;
      payroll_accounting_starts_at?: string;
      payroll_accounting_initial_value_working_time_total_balance?: number;
      public_holiday_template_id?: number;
      public_holiday_template_id_valid_from?: string;
      manual_timetracking?: boolean;
      automatic_tracker_writing_task_id?: number;
      cost_acc_non_working_task_id?: number;
      phone_1?: string;
      phone_2?: string;
      birthday?: string;
      entry_date?: string;
      exit_date?: string;
      notes?: string;
      social_security_number?: string;
      address_1?: string;
      address_2?: string;
      zip?: string;
      permission_show_edit_user_user_settings?: boolean;
      terminal_transponder_nr?: string;
      external_id?: string;
      company_name?: string;
      timesheet_template_id?: number;
      timesheet_template_id_valid_starting_from?: string;
      timesheet_holiday_calc_yearly_amount?: number;
      timesheet_holiday_calc_starting_from?: string;
      timesheet_holiday_calc_interval_mode?: string;
      working_time_balance_rule?: number;
      working_time_balance_rule_valid_from?: string;
      overtime_allowance_included_overtime_hours_per_cycle?: number;
      payroll_accounting_initial_value_holiday?: number;
      timetac_product_id?: number;
      leave_note?: string;
      request_substitute_user_id?: number;
      time_tracking_ex_post_earliest_working_time?: string;
    };
    users_updatePassword: { id: number; password: string };
    userStatusOverview_read: {
      user_id?: number;
      /**
       * Time tracking id of a running task
       */
      time_tracking_id?: number;
      time_tracking_start_time?: string;
      time_tracking_start_time_timezone_id?: string;
      time_tracking_task_id?: number;
      time_tracking_is_nonworking?: boolean;
      /**
       * 1 if there is core time violation, default 0
       */
      core_time_violation?: boolean;
      core_time_start?: string;
      updated?: string;
      is_running?: boolean;
      /**
       * Current absence ids
       */
      current_absence_ids?: string;
      /**
       * Represents current status of users activity if he is offline (0), working(1),break(2),on leave(3), core time violation (5)
       */
      status?: number;
    };
    error401: { error_description?: string; error?: string };
    error403: {
      Host?: string;
      Success?: boolean;
      SuccessNested?: boolean;
      ResourceName?: string;
      RequestStartTime?: string;
      RequestEndTime?: string;
      ServerTimeZone?: string;
      Error?: number;
      ErrorMessage?: string;
      ErrorInternal?: string;
    };
    error410: { Success?: boolean; ErrorMessage?: string; Error?: number };
    error497: { error_description?: string; error?: string };
  };
  responses: {
    /**
     * Unauthorized access
     */
    error401: { [key: string]: any };
    /**
     * No permission for this specific endpoint
     */
    error403: { [key: string]: any };
    /**
     * Endpoint not available - This API endpoint existed in previous API versions, but not in a current version
     */
    error410: { [key: string]: any };
    /**
     * Refresh token has been expired, deleted or tried to issue a new access token with the refresh token but for a different user
     */
    error497: { [key: string]: any };
  };
}
